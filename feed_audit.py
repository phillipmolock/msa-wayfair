# MSA Shopping Feed Audit
# Last Updated 2/19/2021
import os, csv
from statistics import median, mean

# ADVERTISER_NAME is used in the output files
ADVERTISER_NAME = 'AdvertiserName'

# SHOPPING_FEED is the direct path to the shopping feed you'd like to audit
SHOPPING_FEED = 'Path\\to\shopping\\feed.txt'

# SHOPPING_FEED_DELIMITER is the value used to separate columns, the most common is tab (\t)
SHOPPING_FEED_DELIMITER = '\t'

# ROW_COUNT_CHECK_POINT is used to define the interval at which 
# 	Example: a value of 100000 will provide an update every 100000 rows in the feed
#	If working with a smaller feed, set to a smaller value (or set to False to skip this functionality)
ROW_COUNT_CHECK_POINT = 100000

# TRIMMED_ROW_STOP is the row count to stop for building the trimmed feed
TRIMMED_ROW_STOP = 100000

# TEST_RUN is used if you'd like to test the audit on only a small number of offers (defined in TEST_RUN_ROW_STOP). This can be helpful
# 	as many feeds are very large and will take a while to audit and doing a test run can allow you to see the output for a small portion
#	of the feed before doing an entire run.
TEST_RUN = True
TEST_RUN_ROW_STOP = 100000

# OUTPUT_FILE_NAMES is a dictionary mapping the individual output files to their file names
OUTPUT_FILE_NAMES = {
	'duplicate_titles': f'{ADVERTISER_NAME} Shopping Feed Audit - Duplicate Titles.csv',
	'variant_counts': f'{ADVERTISER_NAME} Shopping Feed Audit - Variant Counts.csv',
	'brand_counts': f'{ADVERTISER_NAME} Shopping Feed Audit - Brand Counts.csv',
	'prod_category_counts': f'{ADVERTISER_NAME} Shopping Feed Audit - Prod Category Counts.csv',
	'prod_type_counts': f'{ADVERTISER_NAME} Shopping Feed Audit - Prod Type Counts.csv',
	'custom_label_counts': f'{ADVERTISER_NAME} Shopping Feed Audit - Custom Label Counts.csv',
	'summary_counts': f'{ADVERTISER_NAME} Shopping Feed Audit - Summary.csv',
	'trimmed_shopping_feed': f'{ADVERTISER_NAME} Shopping Feed Audit - Trimmed.csv',
}

# OUTPUT_FILE_NAMES is a dictionary mapping the individual output files to their file names
OUTPUT_FILE_HEADERS = {
	'duplicate_titles': ['title','count of offers','ids'],
	'variant_counts': ['variant type','variant','count of offers'],
	'brand_counts': ['brand','count of offers'],
	'prod_category_counts': ['product category','count of offers'],
	'prod_type_counts': ['product type','count of offers'],
	'custom_label_counts':['custom label level','custom label','count of offers'],
	'summary_counts':['summary value','Detail 1','Detail 2']
}

# OUTPUT_DIRECTORY is the direct path to the output folder where the results of the audit will be stored
OUTPUT_DIRECTORY = 'output'

# main checks for the existence of the SHOPPING_FEED, OUTPUT_DIRECTORY, then runs the feed audit and saves the results
def main():
	if not os.path.exists(SHOPPING_FEED):
		print(f"The file {SHOPPING_FEED} does not exist.\nPlease update the variable SHOPPING_FEED with the direct location of the shopping feed you'd like to audit.")
	elif not os.path.exists(OUTPUT_DIRECTORY):
		print(f"The output directory {OUTPUT_DIRECTORY} does not exist. \nPlease create an output directory (to store the reports generated by this script. And provide the path to that output directory in OUTPUT_DIRECTORY.")
	else:
		title_counts, brand_counts, prod_category_counts, prod_type_counts, custom_label_counts, variant_counts, summary_counts = audit_shopping_feed()
		save_results(title_counts, brand_counts, prod_category_counts, prod_type_counts, custom_label_counts, variant_counts, summary_counts)

# audit_shopping_feed loops through the provided shopping feed auditing for opportunities
def audit_shopping_feed():
	# title_counts is the item ids by title
	title_counts = {}
	brand_counts = {}
	prod_category_counts = {}
	prod_type_counts = {}

	custom_label_counts = {
		'custom_label_0':{},
		'custom_label_1':{},
		'custom_label_2':{},
		'custom_label_3':{},
		'custom_label_4':{},
	}

	variant_counts = {
		'gender':{},
		'size':{},
		'color':{}
	}
		
	summary_counts = {
		'brand_not_in_title':0,
		'color_not_in_title':0,
		'size_not_in_title':0,
		'gender_not_in_title':0,
		'total_offers':0,
		'title_lengths':[],
		'description_lengths':[],
		'feed_header':None,
	}
	trimmed_full_path = os.path.join(OUTPUT_DIRECTORY,OUTPUT_FILE_NAMES['trimmed_shopping_feed'])
	with open(trimmed_full_path, 'w', newline='') as trimmed_feed_out:
		csv_writer = csv.writer(trimmed_feed_out)
		with open(SHOPPING_FEED, 'r', errors='ignore') as feed_in:
			shopping_feed_csv_reader = csv.reader(feed_in, delimiter=SHOPPING_FEED_DELIMITER)
			header = [header_field.lower() for header_field in next(shopping_feed_csv_reader)]
			csv_writer.writerow(header)
			print(header)
			summary_counts['feed_header'] = header
			
			# row_count is used to keep track of how many offers are in a feed
			row_count = 0
			for row in shopping_feed_csv_reader:
				# Increment row_count by 1, if the row count is an interval of the ROW_COUNT_CHECK_POINT
				#	then print out the current row count			
				row_count += 1
				

				if row_count % ROW_COUNT_CHECK_POINT == 0:
					print(f"[Audit Progress] Offer Row: {row_count}")
				if TEST_RUN and row_count == TEST_RUN_ROW_STOP:
					print(f"[Test Audit] Stopping at Offer Row: {row_count}")
					break
				if row_count <= TRIMMED_ROW_STOP:
					csv_writer.writerow(row)
				
				# Core Fields
				item_id = row[header.index('id')]
				title = row[header.index('title')]
				brand = row[header.index('brand')]
				description = row[header.index('description')]
				
				# Save lengths of description and title
				summary_counts['description_lengths'].append(len(description))
				summary_counts['title_lengths'].append(len(title))

				# Increment if brand not in title
				if brand.lower() not in title.lower():
					summary_counts['brand_not_in_title'] += 1

				# Save title in the title_counts dictionary
				if title not in title_counts:
					title_counts[title] = [item_id]
				else:					
					title_counts[title].append(item_id)
				
				# Save brand in brand_counts dictionary
				if brand not in brand_counts:
					brand_counts[brand] = 1
				else:					
					brand_counts[brand] += 1
				
				# Product Variant Fields
				size = row[header.index('size')]
				color = row[header.index('color')]			
				gender = row[header.index('gender')]
				
				# Increment count if size, color, or gender are not in the title
				if size.lower() not in title.lower():
					summary_counts['size_not_in_title'] += 1
				if color.lower() not in title.lower():
					summary_counts['color_not_in_title'] += 1
				if gender.lower() not in title.lower():
					summary_counts['gender_not_in_title'] += 1
				
				# Save size, color, or gender in variant_counts dictionary
				if size not in variant_counts['size']:
					variant_counts['size'][size] = 1
				else:
					variant_counts['size'][size] += 1
				
				if color not in variant_counts['color']:
					variant_counts['color'][color] = 1
				else:
					variant_counts['color'][color] += 1
				
				if gender not in variant_counts['gender']:
					variant_counts['gender'][gender] = 1
				else:
					variant_counts['gender'][gender] += 1
				
				# Product Type and Category Fields
				prod_type = row[header.index('product_type')]
				if prod_type not in prod_type_counts:
					prod_type_counts[prod_type] = 1
				else:
					prod_type_counts[prod_type] += 1									
				
				if 'product_category' in header:
					prod_category = row[header.index('product_category')]
				elif 'google_product_category' in header:
					prod_category = row[header.index('google_product_category')]

				if prod_category not in prod_category_counts:
					prod_category_counts[prod_category] = 1
				else:
					prod_category_counts[prod_category] += 1
				
				# Custom Label Fields
				custom_label_0 = row[header.index('custom_label_0')]
				custom_label_1 = row[header.index('custom_label_1')]
				custom_label_2 = row[header.index('custom_label_2')]
				custom_label_3 = row[header.index('custom_label_3')]
				custom_label_4 = row[header.index('custom_label_4')]
				
				# custom label 0
				if custom_label_0 not in custom_label_counts['custom_label_0']:
					custom_label_counts['custom_label_0'][custom_label_0] = 1
				else:
					custom_label_counts['custom_label_0'][custom_label_0] += 1
				# custom label 1
				if custom_label_1 not in custom_label_counts['custom_label_1']:
					custom_label_counts['custom_label_1'][custom_label_1] = 1
				else:
					custom_label_counts['custom_label_1'][custom_label_1] += 1
				# custom label 2
				if custom_label_2 not in custom_label_counts['custom_label_2']:
					custom_label_counts['custom_label_2'][custom_label_2] = 1
				else:
					custom_label_counts['custom_label_2'][custom_label_2] += 1
				# custom label 3
				if custom_label_3 not in custom_label_counts['custom_label_3']:
					custom_label_counts['custom_label_3'][custom_label_3] = 1
				else:
					custom_label_counts['custom_label_3'][custom_label_3] += 1
				# custom label 4
				if custom_label_4 not in custom_label_counts['custom_label_4']:
					custom_label_counts['custom_label_4'][custom_label_4] = 1
				else:
					custom_label_counts['custom_label_4'][custom_label_4] += 1		
				# Update total offers by row count
				summary_counts['total_offers'] = row_count
	return 	title_counts, brand_counts, prod_category_counts, prod_type_counts, custom_label_counts, variant_counts, summary_counts

# save_results takes the audit data and saves the results to specified outputs
def save_results(title_counts, brand_counts, prod_category_counts, prod_type_counts, custom_label_counts, variant_counts, summary_counts):
	# title counts
	duplicate_title_file_path = os.path.join(OUTPUT_DIRECTORY,OUTPUT_FILE_NAMES['duplicate_titles'])
	print(f"\nSaving duplicate titles to:\n\t{duplicate_title_file_path}")
	with open(duplicate_title_file_path,'w',newline='') as file_out:
		csv_writer = csv.writer(file_out)
		csv_writer.writerow(OUTPUT_FILE_HEADERS['duplicate_titles'])
		for row in [[title,len(skus),skus] for title,skus in title_counts.items() if len(skus) > 1]:
			csv_writer.writerow(row)
	
	# brand counts
	brand_counts_file_path = os.path.join(OUTPUT_DIRECTORY,OUTPUT_FILE_NAMES['brand_counts'])
	print(f"\nSaving brand counts to:\n\t{brand_counts_file_path}")
	with open(brand_counts_file_path,'w',newline='') as file_out:
		csv_writer = csv.writer(file_out)
		csv_writer.writerow(OUTPUT_FILE_HEADERS['brand_counts'])
		for brand, offer_count in brand_counts.items():
			csv_writer.writerow([brand,offer_count])
	
	# prod category counts
	prod_category_file_path = os.path.join(OUTPUT_DIRECTORY,OUTPUT_FILE_NAMES['prod_category_counts'])
	print(f"\nSaving prod category counts to:\n\t{prod_category_file_path}")
	with open(prod_category_file_path,'w',newline='') as file_out:
		csv_writer = csv.writer(file_out)
		csv_writer.writerow(OUTPUT_FILE_HEADERS['prod_category_counts'])
		for prod_category, offer_count in prod_category_counts.items():
			if not prod_category:
				prod_category = 'NO PROD CATEGORY PROVIDED'
			csv_writer.writerow([prod_category,offer_count])
	
	# prod type counts
	prod_type_file_path = os.path.join(OUTPUT_DIRECTORY,OUTPUT_FILE_NAMES['prod_type_counts'])
	print(f"\nSaving prod type counts to:\n\t{prod_type_file_path}")
	with open(prod_type_file_path,'w',newline='') as file_out:
		csv_writer = csv.writer(file_out)
		csv_writer.writerow(OUTPUT_FILE_HEADERS['prod_type_counts'])
		for prod_type, offer_count in prod_type_counts.items():
			if not prod_type:
				prod_type = 'NO PROD TYPE PROVIDED'
			csv_writer.writerow([prod_type,offer_count])
	
	# custom label counts
	custom_label_file_path = os.path.join(OUTPUT_DIRECTORY,OUTPUT_FILE_NAMES['custom_label_counts'])
	print(f"\nSaving custom label counts to:\n\t{custom_label_file_path}")
	with open(custom_label_file_path,'w',newline='') as file_out:
		csv_writer = csv.writer(file_out)
		csv_writer.writerow(OUTPUT_FILE_HEADERS['custom_label_counts'])
		for custom_label_level, custom_label_level_counts in custom_label_counts.items():
			for custom_label, offer_count in custom_label_level_counts.items():
				if not custom_label:
					custom_label = 'NO CUSTOM LABEL PROVIDED'
				csv_writer.writerow([custom_label_level,custom_label,offer_count])

	# variant counts
	variant_file_path = os.path.join(OUTPUT_DIRECTORY,OUTPUT_FILE_NAMES['variant_counts'])
	print(f"\nSaving variant counts to:\n\t{variant_file_path}")
	with open(variant_file_path,'w',newline='') as file_out:
		csv_writer = csv.writer(file_out)
		csv_writer.writerow(OUTPUT_FILE_HEADERS['variant_counts'])
		for variant_type, variant_type_counts in variant_counts.items():			
			for variant, offer_count in variant_type_counts.items():
				if not variant:
					variant = f"NO {variant_type.upper()} PROVIDED"
				csv_writer.writerow([variant_type,variant,offer_count])
	
	# summary counts
	summary_file_path = os.path.join(OUTPUT_DIRECTORY,OUTPUT_FILE_NAMES['summary_counts'])
	print(f"\nSaving summary counts to:\n\t{summary_file_path}")
	with open(summary_file_path,'w',newline='') as file_out:
		csv_writer = csv.writer(file_out)
		csv_writer.writerow(OUTPUT_FILE_HEADERS['summary_counts'])
		
		# get total offers for % calculations
		total_offers = summary_counts['total_offers']

		# feed header
		csv_writer.writerow(['feed header', summary_counts['feed_header']])
		
		# total offers
		csv_writer.writerow(['total offers', summary_counts['total_offers']])
		
		# duplicate offers
		duplicate_counts = sum([len(skus) - 1 for title, skus in title_counts.items()])
		duplicate_counts_percentage = round(100 * (duplicate_counts/total_offers),2)
		csv_writer.writerow(['duplicate offers', duplicate_counts,f'{duplicate_counts_percentage}%'])
		
		# average title length
		csv_writer.writerow(['average title length', round(mean(summary_counts['title_lengths']),2)])
		
		# median title length
		csv_writer.writerow(['median title length', round(median(summary_counts['title_lengths']),2)])
		
		# average description length
		csv_writer.writerow(['average description length', round(mean(summary_counts['description_lengths']),2)])
		
		# median description length
		csv_writer.writerow(['median description length', round(median(summary_counts['description_lengths']),2)])		

		# brand not in title
		brand_counts_percentage = round(100 * (summary_counts['brand_not_in_title']/total_offers),2)
		csv_writer.writerow(['brand not in title', summary_counts['brand_not_in_title'],f'{brand_counts_percentage}%'])

		# color not in title
		color_counts_percentage = round(100 * (summary_counts['color_not_in_title']/total_offers),2)
		csv_writer.writerow(['color not in title', summary_counts['color_not_in_title'],f'{color_counts_percentage}%'])

		# size not in title
		size_counts_percentage = round(100 * (summary_counts['size_not_in_title']/total_offers),2)
		csv_writer.writerow(['size not in title', summary_counts['size_not_in_title'],f'{size_counts_percentage}%'])
		
		# gender not in title
		gender_counts_percentage = round(100 * (summary_counts['gender_not_in_title']/total_offers),2)
		csv_writer.writerow(['gender not in title', summary_counts['gender_not_in_title'],f'{gender_counts_percentage}%'])		

# If run directly, execute main function
if __name__ == "__main__":
	main()